\subsection{Applicazioni}
\label{sec:applications}
Abbiamo esposto le definizioni di base ed introdotto le nozioni di \emph{bisimulazione} e \emph{massima bisimulazione}, per cui riteniamo che sia interessante analizzare alcune applicazioni, prima di entrare nel merito del problema algoritmico.

\accente risaputo che molti sistemi possono essere modellizzati efficacemente utilizzando grafi di complessità arbitraria. Si pensi ad esempio alla rete di contatti tra utenti di un \emph{social network}, di cui i grafi sono la rappresentazione più naturale, o l'insieme delle relazioni all'interno di un qualsiasi tipo di rete meccanica o elettronica (``se il componente $b$ è guasto, allora il componente $a$ è guasto''). Si osservi inoltre la potenza del concetto di \emph{etichetta} (in inglese \emph{label}): se ad esempio volessimo classificare gli utenti di un \emph{social network}, potremmo attribuire alle aziende la \emph{label} di ``\emph{seller}'', agli utenti l'etichetta di ``\emph{user}'', e ad alcuni utenti particolari (che in gergo si dicono \emph{influencer}), le cui opinioni hanno un'ampia risonanza sulla platea degli \emph{user}, l'etichetta di ``\emph{influencer}''. I risultati che otterremmo applicando uno qualsiasi degli algoritmi visti su un grafo di questo genere sarebbero sicuramente molto più profondi ed interessanti rispetto al caso \emph{unlabeled}, in quanto abbiamo diversificato il dataset in base ad informazioni che già avevamo, comunicando all'algoritmo il tipo di classificazione a cui eravamo interessati.

La bisimulazione può essere applicata efficacemente per indicizzare dati semi-strutturati, ovvero dati organizzati in gerarchie di oggetti in cui alcuni attributi possono eventualmente essere assenti \cite{milo}. In mancanza di un'indicizzazione di qualche tipo saremmo costretti, per risolvere una query, ad esplorare tutti i livelli della gerarchia fino a trovare quella sotto-gerarchia di oggetti che la soddisfa. Utilizzando la bisimulazione possiamo raggruppare i dati in classi di equivalenza, e creare quindi una sorta di indice (chiamato \emph{1-index}); in base alle caratteristiche della query possiamo scegliere la classe di equivalenza in cui sappiamo che devono risidere i possibili risultati della ricerca, e restringere quindi la parte di verifica del ``matching'' ai soli membri della classe selezionata, riducendo di molto il tempo richiesto dalla procedura.

\accente possibile applicare la bisimulazione anche nell'ambito della \emph{concurrency theory}, ovvero la teoria che studia l'interazione tra processi software che vengono eseguiti in parallelo. Possiamo costruire un modello semplificato di un sistema di questo tipo tramite la teoria dei grafi. In questo ambito è vitale ridurre problemi come il \emph{deadlock}, una situazione in cui una risorsa ``bloccata'' da un processo non viene mai rilasciata, per cui altri processi in attesa della stessa risorsa si bloccano per un tempo indefinito \cite{concurrency}. Analisi di questo tipo risultano estremamente complesse, soprattutto quando il software diventa molto complesso ed articolato. Per questo motivo esistono degli strumenti, chiamati \emph{concurrency workbench}, per cercare problemi nell'interazione tra processi \cite{caal}, che sfruttano ampiamente diverse nozioni di equivalenza, come appunto la bisimulazione ed alcune sue varianti \cite{kanellakis}.
