\subsection{Applicazioni pratiche}
La bisimulazione è certamente un problema molto interessante dal punto di vista algoritmico: come abbiamo visto nelle sezioni precedenti può essere studiato da angolazioni differenti, con diversi strumenti e concetti relativi alla teoria dei grafi. Il tema però non si esaurisce nello studio, ma trova svariate applicazioni pratiche che ci accingiamo a trattare brevemente nelle prossime righe.

E' risaputo che molti sistemi possono essere modellizzati efficacemente utilizzando grafi di complessità arbitraria. Si pensi ad esempio alla rete di contatti tra utenti di un \emph{social network}, di cui i grafi sono la rappresentazione più naturale, o l'insieme delle relazioni all'interno di un qualsiasi tipo di rete meccanica o elettronica (``se il componente $b$ è guasto, allora il componente $a$ è guasto''). Si osservi inoltre la potenza del concetto di \emph{etichetta} (in inglese \emph{label}): se ad esempio volessimo classificare gli utenti di un \emph{social network}, potremmo attribuire alle aziende la \emph{label} di ``\emph{seller}'', agli utenti l'etichetta di ``\emph{user}'', e ad alcuni utenti particolari (che in gergo si dicono \emph{influencer}), le cui opinioni hanno un'ampia risonanza sulla platea degli \emph{user}, l'etichetta di ``\emph{influencer}''. I risultati che otterremmo applicando uno qualsiasi degli algoritmi visti sopra ad un grafo di questo genere sarebbero sicuramente molto più profondi ed interessanti rispetto al caso \emph{unlabeled}, in quanto abbiamo diversificato il dataset in base ad informazioni che già avevamo, comunicando in un certo senso all'algoritmo il tipo di classificazione a cui eravamo interessati.

Naturalmente la bisimulazione non è un metodo di classificazione universale e privo di difetti: si può osservare molto facilmente infatti che essa non fornisce informazioni quantitative, ma solo qualitative: se da un nodo partono uno o due archi verso nodi di una stessa classe di equivalenza della bisimulazione, non c'è alcuna differenza. Esistono comunque numerosi problemi per cui proprio questa caratteristica consente di pervenire ad una soluzione ottimale: è su questi che ci focalizzeremo nel seguito.

Precisiamo che non intendiamo fornire una trattazione estesa dei temi che tratteremo in questa sezione; ci accontenteremo di proporre una discussione intuitiva sulle motivazioni che ci inducono ad applicare la bisimulazione a questi problemi. Per le applicazioni che considereremo tenteremo di fornire, dove necessario, un apparato formale estremamente ridotto, con la speranza che risulti sintetico, coerente e intuitivo.

\subsubsection{Indicizzazione di dati semistrutturati \cite{milo}}
Consideriamo delle basi di dati che ammettono tipi complessi composti da uno o più attributi, oltre ai tipi semplici come \emph{int, float} e \emph{string}. Supponiamo inoltre che il database consenta di raggiungere una profondità arbitraria, ovvero che non vi sia una profondità limite sotto cui non sono più ammessi tipi complessi. \accente il caso del formato \emph{XML}, o dei database \emph{ad oggetti}. Si tratta chiaramente di un sistema molto versatile, che pone pochissimi vincoli alla natura degli oggetti salvati. Tuttavia, la diminuazione delle assunzioni che possiamo fare sulla struttura dei dati peggiora la velocità di estrazione delle informazioni (\emph{querying}).

I dati sono \emph{strutturati} se possiamo individuare nella gerarchia di tipi complessi una struttura generale (ad esempio, abbiamo un database di \emph{Persone}, ognuna con gli attributi \emph{Nome}, \emph{Cognome}, \emph{Residenza}, dove quest'ultimo è un tipo complesso composto da attributi semplici o composti). Tuttavia in generale alcuni attributi potrebbero mancare, oppure le informazioni che abbiamo sulla struttura potrebbero essere solo parziali: ad esempio, sappiamo che tutti gli oggetti di tipo \emph{Persona} devono avere un sotto-attributo \emph{LuogoDiNascita}, ma non sappiamo quanti sotto-attributi è necessario esplorare prima di pervenire a tale informazione, che potrebbe essere un attributo dell'oggetto \emph{Anagrafica} come dell'oggetto \emph{DatiAnagrafici}. In questa situazione diciamo che i dati sono \emph{semistrutturati}, ed è questo il caso di nostro interesse. Dati di questo tipo possono essere descritti in maniera molto semplice con l'ausilio di un grafo con nodi ed archi ``etichettati''. Senza introdurre il formalismo matematico descritto in maniera esaustiva in \cite{milo}, avremo grafi con diversi \emph{root node} appartenenti ad un insieme $\mathcal{R} \subset V$, ed un insieme di archi $E \subseteq V \times \mathcal{D} \times V$, dove $\mathcal{D}$ è l'insieme dei possibili nomi di attributo (\emph{Nome}, \emph{Residenza}, \dots). Ad ogni nodo associamo un valore semplice (stringa, intero, \dots), che lo caratterizza insieme alla lista di attributi (archi) che partono da tale nodo.

Abbiamo tutti gli ingredienti per rappresentare i dati di cui siamo in possesso, ma risulta evidente la difficoltà nell'interrogazione del database: il fatto che la struttura dei dati sia parzialmente sconosciuta all'utente complica notevolmente l'esplorazione del grafo, in quanto a meno che non si disponga di una "mappa" esaustiva della struttura particolare di tutti i dati siamo obbligati ad effettuare una ricerca esaustiva dell'informazione che intendiamo estrarre. Per questo motivo introduciamo un linguaggio che consente di definire in modo molto naturale i vincoli che i dati ricercati devono rispettare, le \emph{query}. Spenderemo poche parole per caratterizzare questo strumento, in quanto riteniamo che sia molto facile intuirne il funzionamento.
\begin{example}
    La seguente \emph{query} estrae dal dataset la città di residenza di Edsger Dijkstra, ed il numero di abitanti che vi abitano:
    \begin{verbatim}
    SELECT x,y
    FROM * . Dijkstra . Residenza . * . Città . x . * . NumeroAbitanti . y
    \end{verbatim}
    L'operatore ``*'' (\emph{star}) denota un qualsiasi insieme di archi o nodi, e indica che non poniamo alcun vincolo, finchè è rispettata la parte di \emph{query} che segue. Ricerchiamo all'interno del grafo il nodo ``Dijkstra'', il cui attributo ``Residenza'' deve avere tra i suoi successori un attributo ``Città'' che punti ad un oggetto di cui assegnamo il valore alla variabile ``x''; quest'ultimo oggetto deve inoltre avere un attributo (o sotto-attributo) ``NumeroAbitanti'', che punta ad un valore che assegnamo alla variabile ``y''.
\end{example}
Si noti che una \emph{query} in generale può essere soddisfatta da più d'una sequenza di nodi e archi: in tal caso ci aspettiamo che sia ritornato l'intero insieme delle n-uple di incognite estratte da ognuna delle sequenze.

Se risulta evidente la potenza espressiva delle \emph{query}, è anche chiaro che il \emph{matching} di una \emph{query} non è comunque un problema meno complesso della ricerca delle informazioni all'interno del grafo. La soluzione più immediata è chiaramente la ricerca esaustiva di tutti i \emph{matching} per tutte le possibili sequenze, eventualmente con qualche accorgimento per tagliare una ricorsione quando sopravviene l'evidenza dell'impossibilità di pervenire ad una sequenza identificata dalla \emph{query}. Questo tentativo raggiunge molto facilmente la complessità esponenziale (in particolare a causa dell'operatore \emph{star}). Si rende necessario perciò un approccio più ragionato.

Esaminiamo una versione semplificata del problema, che ci consente di mostrare in modo rapido e chiaro un possibile utilizzo dei risultati sulla bisimulazione che abbiamo trattato in questo lavoro. Consideriamo l'insieme delle \emph{query} del tipo \verb|r| \boxed{P} \verb|x|, dove \verb|r| è un qualsiasi \emph{root node} e \boxed{P} è una qualunque formula contenuta in $\mathcal{D}^*$ (si ricordi che $\mathcal{D}$ è l'insieme dei nomi di attributo), ovvero una sequenza arbitraria di nomi di attributo. Cerchiamo un \emph{index-list}, ovvero una struttura che costruiamo sfruttando un'analisi preventiva dei dati, che ci consente in qualche modo di migliorare la velocità di risposta a fronte di interrogazioni future.

Proponiamo innanzitutto un primo approccio, che poi miglioreremo con l'ausilio della bisimulazione. Definiamo l'insieme $L_v$ come segue:
\begin{gather*}
    L_v(G) \coloneqq \{w \in \mathcal{D}^n \mid r \rightarrow_{w_0} v_1 \rightarrow_{w_1} \dots \rightarrow_{w_n} v\}
\end{gather*}
In altre parole, $L_v$ è l'insieme delle gerarchie di attributi in cui si inserisce $v$. Si noti il subscritto degli archi: ricordiamo infatti che l'insieme $E$ è sottoinsieme di $V \times \mathcal{D} \times V$, in quanto ogni arco è caratterizzato dal nome dell'attributo a cui si riferisce.

Definiamo ora una relazione di equivalenza tra nodi di $G$:
\begin{gather*}
    u \equiv v \iff L_u(G) = L_v(G)
\end{gather*}
\accente chiaro che un grafo ausiliario $G'=(V',E')$ avente per nodi le classi di equivalenza di tale relazione, e per archi tutti i tipi di arco che legano almeno una coppia di nodi appartenenti a due classi di equivalenza, costituisce un ottimo \emph{index-list} per il nostro problema: possiamo fare la ricerca su questo grafo ridotto in modo da ridurre drasticamente il numero di archi e nodi visitati. Purtroppo la costruzione di questo grafo è algoritmicamente dispendiosa, per cui usiamo una qualche approssimazione ``$\sim$'', che sia più semplice da calcolare e che soddisfi la seguente proprietà fondamentale:
\begin{gather*}
    u \sim v \implies u \equiv v
\end{gather*}
Ovvero non deve mettere in relazione nodi che non sono in relazione secondo ``$\equiv$'', condizione che si può esprimere anche come ``$\sim \,\,\subseteq \,\, \equiv$''. Inoltre auspichiamo che i casi in cui vale:
\begin{gather*}
    u \equiv v \land u \not\sim v
\end{gather*}
siano pochi, ovvero che l'approssimazione sia molto buona. Si osservi che se l'approssimazione non è buona non otteniamo risultati sbagliati, ma solo una maggiore cardinalità di $V'$ e $E'$, fattore che riduce il miglioramento che introduciamo adottando un \emph{index-list}.

Si può dimostrare che un buon approssimante per ``$\equiv$'' è la bisimulazione massima, con una definizione leggermente modificata per tenere in considerazione archi con etichetta (interagiscono solo coppie di archi con la stessa etichetta) ed il fatto che per il nostro problema siamo interessati al percorso che porta ad un certo nodo, piuttosto che all'insieme dei nodi raggiungibili da tale nodo (chiamiamo una relazione di questo tipo \emph{reversed labeled bisimulation}). Nonostante quest'ultima condizione sembri richiedere una trattazione totalmente diversa rispetto a quella delineata nelle sezioni precedenti, osserviamo che è sufficiente calcolare la bisimulazione massima sul grafo trasposto. Inoltre si può dimostrare che sotto opportune ipotesi, peraltro abbastanza deboli nell'ambito che stiamo considerando, la relazione binaria ``$\equiv$'' e la bisimulazione massima coincidono.

L'\emph{index-list} che abbiamo descritto è conosciuto in letteratura come \emph{1-index}. Sfruttando un ragionamento simile ed una ulteriore variante della bisimulazione possiamo trattare \emph{query} del tipo * $x$ \boxed{P} $y$ (\emph{2-index}). Questi due \emph{index-list} rappresentano tutti i possibili percorsi all'interno del grafo (\emph{2-index}) o da un \emph{root node} ad un nodo (\emph{1-index}), e possono essere utilizzati in combinazione per risolvere \emph{query} più complesse.

Omettiamo i dettagli tenici, come il miglioramento nella velocità di risoluzione delle \emph{query}, in quanto all'interno di questa sezione intendiamo solamente proporre alcune applicazioni ``ad alto livello'' degli algoritmi che abbiamo presentato in questo lavoro, senza addentrarci nell'implementazione e negli accorgimenti che si rendono necessari.

\subsubsection{Calculus for communicating systems}
La versatilità dei grafi consente di modellizzare, con opportuni accorgimenti, processi concorrenti che comunicano e che condividono risorse \cite{milner}, \cite{intro_calculus}. Il campo della \emph{concurreny theory}, ovvero la teoria che studia il comportamento e l'interazione di processi simultanei, è chiaramente di vitale importanza in un periodo storico in cui ai calcolatori vengono demandate computazioni sempre più pesanti. Il tentativo di sfruttare al meglio le possibilità dell'hardware non può esaurirsi chiaramente nella scrittura di codice performarne; è necessario progettare accuratamente un'architettura software in cui non vi siano, ad esempio, \emph{bottleneck} (in italiano \emph{colli di bottiglia}, punti del programma in cui più processi restano in attesa di una risorsa che viene fornita con una frequenza relativamente bassa) o \emph{deadlock} (un processo resta in attesa di un messaggio che non verrà mai inviato) \cite{concurrency}. A tal fine si rende necessario l'utilizzo di strumenti specifici che facilitino questa analisi, che risulta molto difficoltosa se fatta ``a mano'' qualora si prendano in considerazione software molto corposi.

Questi strumenti devono consentire innanzitutto la rappresentazione dei processi (che in questo ambito chiamiamo \emph{agenti}) che intervengono durante l'esecuzione del software. Omettendo alcuni dettagli formali poco utili per la discussione del tutto intuitiva che intendiamo proporre, ogni \emph{agente} viene modellizzato tramite un nodo di un grafo, i cui archi incidenti costituiscono transizioni da o verso altri \emph{agenti} a seguito di un particolare evento, identificato da una etichetta univoca. Nodi legati da archi possono dunque essere pensati come stati sequenziali di uno stesso processo, concezione che rende la teoria molto simile a quella degli automi.

Il CCS (\emph{Calculus for communicating systems}) si differenzia dalla teoria degli automi con l'introduzione di ``operatori'' (chiamati \emph{costruttori}) che consentono di definire nuovi processi in modo molto naturale, in funzione di processi di base più semplici. Ad esempio, il costruttore ``+'' (somma) definisce un nuovo operatore $a + b$ a partire da due operatori più semplici $a,b$, il quale raccoglie tutte le transizioni da e verso i due \emph{agenti}; $a + b$ è quindi un processo che reagisce ad un evento come se fosse $a$ o $b$ a seconda di quale dei due \emph{agenti} di base sia ``programmato'' per reagire a quel determinato evento (supponiamo per semplicità che non vi siano sovrapposizioni). Più interessante è sicuramente il costruttore ``$\mid$'' (composizione), che viene utilizzato per dichiarare che due processi $a,b$ vivono indipendentemente in generale, ma che possono all'occorrenza comunicare \cite{intro_calculus}.

Modellizzato il sistema per mezzo di \emph{agenti} e transizioni tra \emph{agenti} intendiamo operare un analisi che fornisca qualche tipo di informazione sulle relazioni che intercorrono tra gli stati dei processi concorrenti che stiamo considerando. A questo scopo risulta di primaria importanza definire una sorta di congruenza tra \emph{agenti}. \accente evidente infatti che vi siano \emph{agenti} che reagiscono esattamente nello stesso modo, pur ad eventi diversi. Sono state proposte diverse tipologie di congruenza \cite{kanellakis}, ognuna delle quali cattura un diverso tipo di similitudine tra gli \emph{agenti}; ci interessiamo ovviamente a quella definita per mezzo della bisimulazione, che in letteratura viene chiamata \emph{strong equivalence}. L'introduzione di questa nozione nella teoria, tra le altre cose, garantisce la validità di proprietà molto utili, che non sarebbe possibile esprimere senza la definizione di qualche tipo di congruenza, come la commutatività del costruttore somma (\cite{intro_calculus}, Capitolo 4). L'applicazione degli algoritmi visti sopra per il calcolo della bisimulazione massima del grafo diretto dato dagli \emph{agenti} con cui abbiamo modelizzato il sistema consente di effettuare un analisi preventiva delle relazioni che intercorrono tra i processi che compongono il software che intendiamo esaminare, ridurre la dimensionalità del grafo tenendo solamente le classi di equivalenza della bisimulazione massima, per poi effettuare ulteriori analisi (al fine di identificare appunto problemi come il \emph{deadlock}) con strumenti più raffinati. E' quanto fanno software chiamati \emph{concurrency workbench}, come \cite{ncsu}, \cite{caal}, \cite{cwnc}, sfruttando peraltro proprio gli algoritmi che abbiamo presentato nelle precedenti sezioni, in particolare quello di Paige-Tarjan (\cite{dovier}, Sezione 2).
