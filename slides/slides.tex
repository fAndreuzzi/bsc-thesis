\documentclass{beamer}
\usepackage{tikz}
\usepackage{scalerel}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{mathtools}
\usepackage{hyperref}
\usepackage{amsmath}

%Information to be included in the title page:
\title{\texttt{BisPy}}
\subtitle{un pacchetto Python per il calcolo della massima bisimulazione di grafi diretti.}

\author{Francesco Andreuzzi}
\institute{Università degli Studi di Trieste,\\Dipartimento di Ingegneria e Architettura}
\date{14 Luglio 2021}

\begin{document}
\beamertemplatenavigationsymbolsempty

{\usebackgroundtemplate{%
    \parbox[c][\paperheight][c]{\paperwidth}{\centering \tikz\node[opacity=0.08] {\includegraphics[width=8cm,height=8cm]{../imgs/logo.png}};}}
    \begin{frame}
        \maketitle
        {\scriptsize Anno accademico 2020-2021 \hfill Relatore: Prof. Alberto Casagrande}
    \end{frame}
}

% I grafi diretti sono strutture matematiche composte da un insieme V di nodi e da un insieme E di archi. Sono oggetti interessanti
% perchè consentono di creare un modello matematico di sistemi di vario genere (social network, impianti industriali, catene logistiche).
% Per questo motivo lo studio della teoria dei grafi è trasversale rispetto a molti ambiti.
\begin{frame}\frametitle{Grafi diretti}

    \begin{figure}[t]
        \centering
        \begin{tikzpicture}[scale=0.5]
            \begin{scope}[every node/.style={circle,thick,draw}]
                \node (a) at (0,0) {a};
                \node (b) at (0,3) {b};
                \node (c) at (2.5,4) {c};
                \node (d) at (2.5,1) {d};
                \node (e) at (5,3) {e};
            \end{scope}

            \begin{scope}
                \path [->] (a) edge node {} (b);
                \path [->] (b) edge node {} (c);
                \path [->] (a) edge node {} (d);
                \path [->] (d) edge node {} (c);
                \path [->] (d) edge node {} (e);
                \path [->] (c) edge node {} (e);
            \end{scope}
            \end{tikzpicture}
    \end{figure}

    \begin{gather*}
        V = \{a,b,c,d,e\}\\
        E = \{\langle a,b\rangle, \langle b,c\rangle, \langle a,d\rangle, \langle c,e\rangle, \langle d,e\rangle\}
    \end{gather*}
\end{frame}

% Per alcune applicazioni può essere utile avere a disposizione una nozione di equivalenza tra nodi. Il mio lavoro di tesi si è
% focalizzato su una possibile definizione di equivalenza, la massima bisimulazione. Due nodi sono bisimili quando preso uno qualsiasi
% dei due, per ogni suo figlio esiste un figlio dell'altro nodo bisimile al primo figlio scelto.
% slide 1, vediamo un esempio. E' chiaro che due pozzi sono bisimili per la definizione.
% slide 2, anche in questo caso è facile verificare la definizione.
% slide 3, è chiaro che aumentando la complessità del grafo diventa impossibile trovare la massima bisimulazione ad occhio.
\begin{frame}\frametitle{Bisimulazione I}
    \begin{gather*}
        a \equiv b \implies
        \begin{cases}
            \langle a, a' \rangle \in E \implies \exists b' \mid \langle b, b' \rangle \in E \land a' \equiv b'\\
            \langle b, b' \rangle \in E \implies \exists a' \mid \langle a, a' \rangle \in E \land b' \equiv a'
        \end{cases}
    \end{gather*}

    \begin{figure}
        \begin{tikzpicture}[scale=0.5]
            \begin{scope}[every node/.style={circle,thick,draw}]
                \node (a) at (0,0) {a};
                \node (b) at (0,3) {b};
            \end{scope}
            \end{tikzpicture}
    \end{figure}
\end{frame}

\begin{frame}\frametitle{Bisimulazione II}
    \begin{gather*}
        a \equiv b \implies
        \begin{cases}
            \langle a, a' \rangle \in E \implies \exists b' \mid \langle b, b' \rangle \in E \land a' \equiv b'\\
            \langle b, b' \rangle \in E \implies \exists a' \mid \langle a, a' \rangle \in E \land b' \equiv a'
        \end{cases}
    \end{gather*}

    \begin{figure}
        \begin{tikzpicture}[scale=0.5]
            \begin{scope}[every node/.style={circle,thick,draw}]
                \node (a) at (0,0) {a};
                \node (b) at (0,3) {b};
                \node (c) at (-2,1.5) {c};
                \node (d) at (2,1.5) {d};
            \end{scope}

            \begin{scope}
                \path [->] (c) edge node {} (a);
                \path [->] (d) edge node {} (b);
            \end{scope}
            \end{tikzpicture}
    \end{figure}
\end{frame}

\begin{frame}\frametitle{Bisimulazione III}
    \begin{gather*}
        a \equiv b \implies
        \begin{cases}
            \langle a, a' \rangle \in E \implies \exists b' \mid \langle b, b' \rangle \in E \land a' \equiv b'\\
            \langle b, b' \rangle \in E \implies \exists a' \mid \langle a, a' \rangle \in E \land b' \equiv a'
        \end{cases}
    \end{gather*}

    \begin{figure}
        \begin{tikzpicture}[scale=0.5]
            \begin{scope}[every node/.style={circle,thick,draw}]
                \node (a) at (0,0) {a};
                \node (b) at (0,3) {b};
                \node (c) at (-2,1.5) {c};
                \node (d) at (2,1.5) {d};
                \node (e) at (-4,1.5) {e};
                \node (f) at (-5,3) {f};
                \node (g) at (-5,0) {g};
                \node (h) at (3,0) {h};
                \node (i) at (4,3) {i};
                \node (j) at (5,0) {j};
            \end{scope}

            \begin{scope}
                \path [->] (c) edge node {} (a);
                \path [->] (d) edge node {} (b);

                \path [->] (f) edge node {} (c);
                \path [->] (f) edge node {} (e);
                \path [->] (g) edge node {} (a);
                \path [->] (g) edge [loop below] node {} (g);
                \path [->] (e) edge node {} (g);

                \path [->] (h) edge node {} (a);
                \path [->] (h) edge node {} (d);
                \path [->] (i) edge [bend right] node {} (j);
                \path [->] (j) edge node {} (i);
                \path [->] (h) edge node {} (j);
            \end{scope}
            \end{tikzpicture}
    \end{figure}
\end{frame}

\begin{frame}\frametitle{Massima bisimulazione}
    \begin{gather*}
        \equiv_\mathcal{M} \,\,\,\,\,= \bigcup_{\substack{\mathcal{R} \text{ è una}\\\text{bisimulazione}}} \mathcal{R}.
    \end{gather*}
    \begin{itemize}
        \item $\equiv_\mathcal{M}$ è ancora una \emph{bisimulazione};
        \item $\equiv_\mathcal{M}$ è una \emph{relazione di equivalenza}

        $\implies$ induce un partizionamento su $V$.
    \end{itemize}
\end{frame}

\begin{frame}\frametitle{Algoritmi}
    \begin{itemize}
        \item Algoritmo di Paige-Tarjan
        \item Algoritmo di Dovier-Piazza-Policriti
        \item Algoritmo incrementale di Saha
    \end{itemize}
\end{frame}

\begin{frame}[fragile]\frametitle{BisPy}
    \begin{itemize}
        \item Python 3
        \item Open source (\url{https://github.com/fAndreuzzi/BisPy})
    \end{itemize}

    \begin{verbatim}
    import networkx as nx
    from bispy import paige_tarjan

    # creazione del grafo
    graph = nx.balanced_tree(2,3)

    # calcolo della massima bisimulazione
    print(paige_tarjan(graph))

    >>> [(7, 8, 9, 10, 11, 12, 13, 14), (3, 4, 5, 6),
        (1, 2), (0,)]
    \end{verbatim}
\end{frame}

\begin{frame}\frametitle{Risultati sperimentali}
\end{frame}

\begin{frame}\frametitle{Sviluppi futuri}
    \begin{itemize}
        \item Incremental delete: ricalcolo incrementale della massima bisimulazione dopo la \textbf{rimozione} di un arco;
        \item Labeled edges;
        \item Migliore integrazione con altre librerie (\texttt{NetworkX});
        \item Riscrittura in \texttt{Cython} di parti critiche del codice.
    \end{itemize}

    \begin{gather*}
        a \equiv b \implies
        \begin{cases}
            \langle a, a' \rangle^\ell \in E \implies \exists b' \mid \langle b, b' \rangle^\ell \in E \land a' \equiv b'\\
            \langle b, b' \rangle^\ell \in E \implies \exists a' \mid \langle a, a' \rangle^\ell \in E \land b' \equiv a'
        \end{cases}
    \end{gather*}
\end{frame}

\begin{frame}
    Grazie per l'attenzione
\end{frame}

\end{document}
