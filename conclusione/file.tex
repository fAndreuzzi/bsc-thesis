\section{Conclusioni}
\label{sec:conclusions}
In questo elaborato è stata presentata la \emph{massima bisimulazione} ed alcuni degli algoritmi più utilizzati per il calcolo. Inoltre è stato presentato un pacchetto Python contenente l'implementazione degli algoritmi, di cui abbiamo valutato le performance su varie tipologie di grafo.

Intendiamo continuare lo sviluppo del pacchetto come progetto open source, possibilmente cercando di coinvolgere anche altri sviluppatori interessati all'argomento. Per quello che abbiamo potuto osservare non ci sono altri progetti Python che trattino la bisimulazione in modo approfondito, per cui riteniamo che vi sia una certa componente di originalità nel lavoro, che ci motiva a portare avanti il progetto. Vi sono numerose funzionalità che sarebbe auspicabile introdurre in futuro per rendere \texttt{BisPy} più versatile ed applicabile in contesti pratici:
\begin{itemize}
    \item \emph{Labeled edges}: La possibilità di assegnare etichette agli archi consente di formulare modelli più espressivi e risolvere problemi più complessi ed interessanti, infatti le applicazioni che abbiamo considerato nella Sezione \ref{sec:applications} beneficiano notevolmente di questa variante della bisimulazione. Sono sufficienti alcuni cambiamenti di lieve entità agli algoritmi originali per supportare questa generalizzazione (\cite{dovier}, Sezione 7), che aumenterebbe molto l'applicabilità del pacchetto in contesti pratici;
    \item \emph{k-bisimulazione}: In alcuni casi la bisimulazione fornisce un partizionamento del grafo troppo approfondito, inutilizzabile all'atto pratico, poichè ciò che succede ``lontano'' da un nodo talvolta è di poca importanza per quel nodo; per questo motivo si introduce una variante, la k-bisimulazione, in cui le caratteristiche topologiche di un nodo (gli archi nella sua immagine, gli archi nell'immagine dei successori del nodo, \dots) vengono considerate solo in un ``intorno'' di raggio $k \geq 0$ \cite{kbisi}; la k-bisimulazione peraltro è piuttosto economica da calcolare, e trova quindi diverse applicazioni pratiche;
    \item Migliorare la compatibilità con altri package Python nell'ambito della teoria dei grafi, come ad esempio \emph{NetworkX}, in modo da poter sfruttare altre librerie per aggiungere nuove funzionalità, o per poter ingrandire l'insieme di formati di input supportati.
\end{itemize}
