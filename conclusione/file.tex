\section*{Conclusioni}
\addcontentsline{toc}{section}{Conclusioni}
\label{sec:conclusions}

In questo elaborato abbiamo studiato il problema della \emph{massima bisimulazione}, ed alcuni algoritmi che utilizzano metodi diversi per la risoluzione del problema. Inoltre abbiamo presentato il pacchetto \texttt{BisPy}, parte integrante di questo lavoro. Durante il processo di implementazione del software è risultata fondamentale l'analisi condotta nella Sezione \ref{sec:algs}, che ha consentito di acquisire una comprensione profonda del tema e delle metodologie utilizzate per la risoluzione. Il pacchetto è stato utilizzato per valutare il tempo di esecuzione degli algoritmi considerati su varie tipologie di grafo, e per verificare la coerenza dei risultati ottenuti con quanto è emerso dall'analisi.

Intendiamo continuare lo sviluppo del pacchetto come progetto \emph{open source}, in quanto sono numerose le funzionalità che sarebbe auspicabile aggiungere al fine di rendere \texttt{BisPy} più versatile ed applicabile in contesti pratici. Per quello che abbiamo potuto osservare non ci sono altri progetti Python che trattino la bisimulazione in modo approfondito, per cui riteniamo che vi sia una certa componente di originalità nel lavoro. Di seguito sono elencate alcune migliorie e funzionalità che potrebbero essere aggiunte al progetto in futuro:
\begin{itemize}
    \item \emph{Labeled edges}: La possibilità di assegnare etichette agli archi consente di formulare modelli più espressivi e risolvere problemi più complessi ed interessanti, infatti le applicazioni che abbiamo considerato nella Sezione \ref{sec:applications} beneficiano notevolmente di questa variante della bisimulazione. Sono sufficienti alcuni cambiamenti di lieve entità agli algoritmi originali per supportare questa generalizzazione (\cite{dovier}, Sezione 7), che aumenterebbe molto l'applicabilità del pacchetto in contesti pratici;
    \item \emph{k-bisimulazione}: In alcuni casi la bisimulazione fornisce un partizionamento del grafo troppo approfondito, inutilizzabile all'atto pratico, poichè ciò che succede ``lontano'' da un nodo talvolta è di poca importanza per quel nodo; per questo motivo si introduce una variante, la k-bisimulazione, in cui le caratteristiche topologiche di un nodo (gli archi nella sua immagine, gli archi nell'immagine dei successori del nodo, \dots) vengono considerate solo in un ``intorno'' di raggio $k \geq 0$ \cite{kbisi}; la k-bisimulazione peraltro è piuttosto economica da calcolare, e trova quindi diverse applicazioni pratiche;
    \item Migliorare la compatibilità con altri package Python nell'ambito della teoria dei grafi, come ad esempio \texttt{NetworkX}, in modo da poter sfruttare altre librerie per aggiungere nuove funzionalità, o per poter ingrandire l'insieme di formati di input supportati;
    \item Scrivere alcune porzioni di codice critiche utilizzando \texttt{Cython} (ad esempio, la ricerca dei \emph{causal splitter} nell'Algoritmo di Saha).
\end{itemize}
