\section*{Conclusioni}
\addcontentsline{toc}{section}{Conclusioni}
\label{sec:conclusions}

In questo elaborato abbiamo presentato la \emph{massima bisimulazione} ed alcuni degli algoritmi più utilizzati per il calcolo della massima bisimulazione di grafi diretti. Inoltre è stato presentato un pacchetto Python contenente l'implementazione degli algoritmi, che consideriamo parte integrante di questo lavoro, e per cui è risultata fondamentale l'analisi condotta nella Sezione \ref{sec:algs}. Per tale pacchetto abbiamo valutato il tempo di esecuzione su varie tipologie di grafo, verificando la coerenza dei risultati ottenuti con quanto è emerso dall'analisi.

Intendiamo continuare lo sviluppo del pacchetto come progetto open source, in quanto sono numerose le funzionalità che sarebbe auspicabile aggiungere al fine di rendere \texttt{BisPy} più versatile ed applicabile in contesti pratici. Per quello che abbiamo potuto osservare non ci sono altri progetti Python che trattino la bisimulazione in modo approfondito, per cui riteniamo che vi sia una certa componente di originalità nel lavoro, che ci motiva a portare avanti il progetto.

Di seguito elenchiamo alcune delle migliorie che intendiamo apportare in futuro:
\begin{itemize}
    \item \emph{Labeled edges}: La possibilità di assegnare etichette agli archi consente di formulare modelli più espressivi e risolvere problemi più complessi ed interessanti, infatti le applicazioni che abbiamo considerato nella Sezione \ref{sec:applications} beneficiano notevolmente di questa variante della bisimulazione. Sono sufficienti alcuni cambiamenti di lieve entità agli algoritmi originali per supportare questa generalizzazione (\cite{dovier}, Sezione 7), che aumenterebbe molto l'applicabilità del pacchetto in contesti pratici;
    \item \emph{k-bisimulazione}: In alcuni casi la bisimulazione fornisce un partizionamento del grafo troppo approfondito, inutilizzabile all'atto pratico, poichè ciò che succede ``lontano'' da un nodo talvolta è di poca importanza per quel nodo; per questo motivo si introduce una variante, la k-bisimulazione, in cui le caratteristiche topologiche di un nodo (gli archi nella sua immagine, gli archi nell'immagine dei successori del nodo, \dots) vengono considerate solo in un ``intorno'' di raggio $k \geq 0$ \cite{kbisi}; la k-bisimulazione peraltro è piuttosto economica da calcolare, e trova quindi diverse applicazioni pratiche;
    \item Migliorare la compatibilità con altri package Python nell'ambito della teoria dei grafi, come ad esempio \texttt{NetworkX}, in modo da poter sfruttare altre librerie per aggiungere nuove funzionalità, o per poter ingrandire l'insieme di formati di input supportati;
    \item Scrivere alcune porzioni di codice critiche utilizzando \texttt{Cython} (ad esempio, la ricerca dei \emph{causal splitter} nell'Algoritmo di Saha).
\end{itemize}
